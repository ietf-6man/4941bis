<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

<?rfc subcompact="no" ?>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes"?>

<rfc obsoletes="rfc4941" category="std" ipr="trust200902"
docName="draft-ietf-6man-rfc4941bis-04">
  <front>
    <title abbrev="Privacy Extensions to Autoconf">Privacy
    Extensions for Stateless Address Autoconfiguration in
    IPv6</title>


    <author fullname="Fernando Gont" initials="F." surname="Gont">

      <organization abbrev="SI6 Networks / UTN-FRH">SI6 Networks /
UTN-FRH</organization>
      <address>
        <postal>
          <street>Evaristo Carriego 2644</street>
          <code>1706</code>
          <city>Haedo</city>
          <region>Provincia de Buenos Aires</region>
          <country>Argentina</country>
        </postal>
        <phone>+54 11 4650 8472</phone>
        <email>fgont@si6networks.com</email>
        <uri>http://www.si6networks.com</uri>
       </address>
    </author>


    <author initials="S.K." surname="Krishnan"
    fullname="Suresh Krishnan">
      <organization>Ericsson Research</organization>
      <address>
        <postal>
          <street>8400 Decarie Blvd.</street>
          <city>Town of Mount Royal</city>
          <region>QC</region>
          <country>Canada</country>
        </postal>
        <email>suresh.krishnan@ericsson.com</email>
      </address>
    </author>

    <author initials="T.N." surname="Narten"
    fullname="Thomas Narten">
      <organization>IBM Corporation</organization>
      <address>
        <postal>
          <street>P.O. Box 12195</street>
          <city>Research Triangle Park</city>
          <region>NC</region>
          <country>USA</country>
        </postal>
        <email>narten@us.ibm.com</email>
      </address>
    </author>
    <author initials="R.D." surname="Draves"
    fullname="Richard Draves">
      <organization>Microsoft Research</organization>
      <address>
        <postal>
          <street>One Microsoft Way</street>
          <city>Redmond</city>
          <region>WA</region>
          <country>USA</country>
        </postal>
        <email>richdr@microsoft.com</email>
      </address>
    </author>


    <date/>

    <area>Internet</area>
    <workgroup>IPv6 Maintenance (6man) Working Group</workgroup>

<!-- [rfced] Please insert any keywords (beyond those that appear in
the title) for use on http://www.rfc-editor.org/search.html. -->

<keyword>privacy</keyword>
<keyword>anonymity</keyword> 
<keyword>unlinkability</keyword>
<keyword>crypto-based address changing</keyword>


    <abstract>
      <t>Nodes use IPv6 stateless address autoconfiguration to
      generate addresses using a combination of locally available
      information and information advertised by routers. Addresses
      are formed by combining network prefixes with an interface
      identifier. This document describes an extension that causes 
      nodes to generate global scope addresses with randomized interface identifiers
      that change over time. Changing global scope addresses over time makes it more
      difficult for eavesdroppers and other information collectors
      to identify when different addresses used in different
      transactions actually correspond to the same node. This document formally obsoletes RFC4941.</t>
    </abstract>
  </front>
  <middle>
    <section anchor="intro" title="Introduction">
      <t>Stateless address autoconfiguration 
      <xref target='RFC4862' /> defines how an IPv6 node generates
      addresses without the need for a Dynamic Host Configuration Protocol for IPv6 (DHCPv6) server. The security and privacy implications of such addresses have been discussed in great detail in <xref target="RFC7721"/>,<xref target="RFC7217"/>, and RFC7707. This document specifies an extension for SLAAC to generate temporary addresses, such that the aforementioned issues are mitigated.</t>

<t>The default address selection for IPv6 has been specified in <xref target="RFC6724"/>. We note that the determination as to whether to use stable versus temporary addresses can in some cases only be made by an application. For example, some applications may always want
      to use temporary addresses, while others may want to use them
      only in some circumstances or not at all. An API such as that specified in <xref target="RFC5014"/> can enable
      individual applications to indicate with sufficient granularity their needs with regards to the use of temporary
      addresses.
</t>

      <t>
      <xref target='SECTION2' /> provides background information on
      the issue. 
      <xref target='SECTION3' /> describes a procedure for
      generating temporary interface identifiers and global scope
      addresses. 
      <xref target='SECTION4' /> discusses implications of changing
      interface identifiers. 
</t>

	<section title="Terminology" anchor="term">

<!--
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
        "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY",
        and "OPTIONAL" in this document are to be interpreted as
        described in 
        <xref target='RFC2119' />.</t>
-->

<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
      "MAY", and "OPTIONAL" in this document are to be interpreted as
      described in BCP 14 <xref target='RFC2119' /> <xref target='RFC8174' /> when, and only when, they
      appear in all capitals, as shown here.
</t>


	<t>The terms "public address", "stable address", "temporary address", "constant IID", "stable IID", and "temporary IID" are to be
       interpreted as specified in <xref target="RFC7721"/>.</t>

<t>The term "global scope addresses" is
      used in this document to collectively refer to "Global
      unicast addresses" as defined in 
      <xref target='RFC4291' /> and "Unique local addresses" as
      defined in 
      <xref target='RFC4193' />, and not to "globally reachable" as defined in <xref target="RFC8190"/>.</t>

</section>

      <section title="Problem Statement">
        <t>Addresses generated using stateless address
        autoconfiguration 
        <xref target='RFC4862' /> contain an embedded interface
        identifier, which remains stable over time. Anytime a
        fixed identifier is used in multiple contexts, it becomes
        possible to correlate seemingly unrelated activity using
        this identifier.</t>
        <t>The correlation can be performed by 
        <list style="symbols">
		<t>An attacker who is in the path between the node in
          question and the peer(s) to which it is communicating, and
          who can
          view the IPv6 addresses present in the datagrams.</t>
          <t>An attacker who can access the communication logs of
          the peers with which the node has communicated.</t>
        </list></t>
        <t>Since the identifier is embedded within the IPv6
        address, which is a fundamental requirement of
        communication, it cannot be easily hidden. This document
        proposes a solution to this issue by generating interface
        identifiers that vary over time.</t>
        <t>Note that an attacker, who is on path, may be able to
        perform significant correlation based on 
        <list style="symbols">
          <t>The payload contents of the packets on the wire</t>
          <t>The characteristics of the packets such as packet size
          and timing</t>
        </list>Use of temporary addresses will not prevent such
        payload-based correlation, which can only be addressed by widespread deployment of encryption as advocated in <xref target="RFC7624"/>.</t>
      </section>
    </section>
<!--    <vspace blankLines="100" /> -->

    <section anchor="SECTION2" title="Background">
      <t>This section discusses the problem in more detail,
      provides context for evaluating the significance of the
      concerns in specific environments and makes comparisons with
      existing practices.</t>
      <section title="Extended Use of the Same Identifier">
        <t>The use of a non-changing interface identifier to form
        addresses is a specific instance of the more general case
        where a constant identifier is reused over an extended
        period of time and in multiple independent activities.
        Any time the same identifier is used in multiple contexts,
        it becomes possible for that identifier to be used to
        correlate seemingly unrelated activity. For example, a
        network sniffer placed strategically on a link across which
        all traffic to/from a particular host crosses could keep
        track of which destinations a node communicated with and at
        what times. Such information can in some cases be used to
        infer things, such as what hours an employee was active,
        when someone is at home, etc. Although it might appear that
        changing an address regularly in such environments would be
        desirable to lessen privacy concerns, it should be noted
        that the network prefix portion of an address also serves
        as a constant identifier. All nodes at, say, a home, would
        have the same network prefix, which identifies the
        topological location of those nodes. This has implications
        for privacy, though not at the same granularity as the
        concern that this document addresses. Specifically, all
        nodes within a home could be grouped together for the
        purposes of collecting information. If the network contains
        a very small number of nodes, say, just one, changing just
        the interface identifier will not enhance privacy at all,
        since the prefix serves as a constant identifier.</t>
        <t>One of the requirements for correlating seemingly
        unrelated activities is the use (and reuse) of an
        identifier that is recognizable over time within different
        contexts. IP addresses provide one obvious example, but
        there are more. Many nodes also have DNS names associated
        with their addresses, in which case the DNS name serves as
        a similar identifier. Although the DNS name associated with
        an address is more work to obtain (it may require a DNS
        query), the information is often readily available. In such
        cases, changing the address on a machine over time would do
        little to address the concerns raised in this document,
        unless the DNS name is changed as well (see 
        <xref target='SECTION4' />).</t>
        <t>Web browsers and servers typically exchange "cookies"
        with each other 
        <xref target='RFC6265' />. Cookies allow web servers to
        correlate a current activity with a previous activity. One
        common usage is to send back targeted advertising to a user
        by using the cookie supplied by the browser to identify
        what earlier queries had been made (e.g., for what type of
        information). Based on the earlier queries, advertisements
        can be targeted to match the (assumed) interests of the
        end-user.</t>
        <t>The use of a constant identifier within an address is of
        special concern because addresses are a fundamental
        requirement of communication and cannot easily be hidden
        from eavesdroppers and other parties. Even when higher
        layers encrypt their payloads, addresses in packet headers
        appear in the clear. Consequently, if a mobile host (e.g.,
        laptop) accessed the network from several different
        locations, an eavesdropper might be able to track the
        movement of that mobile host from place to place, even if
        the upper layer payloads were encrypted.</t>

<t>Using temporary address alone may not be sufficient to prevent all forms of tracking. It
is however quite clear that some usage of temporary addresses is necessary to
improve user privacy.</t>

		<t>The security and privacy implications of IPv6 addresses are discussed in
           detail in <xref target="RFC7721"/>, <xref target="RFC7707"/>, and <xref target="RFC7217"/>.
</t>
      </section>


      <section title="Possible Approaches">
        <t>One way to avoid having a stable non-changing address is
        to use DHCPv6 <xref target='RFC8415' /> for obtaining addresses. 
	Section 12 of 
        <xref target='RFC8415' /> discusses the use of DHCPv6 for the
        assignment and management of "temporary addresses", which
        are never renewed and provide the same property of
        temporary addresses described in this document with regards
        to the privacy concern.</t>
        <t>Another approach, compatible with the stateless address
        autoconfiguration architecture, would be to change the
        interface identifier portion of an address over time. Changing 
        the interface identifier can
        make it more difficult to look at the IP addresses in
        independent transactions and identify which ones actually
        correspond to the same node, both in the case where the
        routing prefix portion of an address changes and when it
        does not.</t>

        <t>Many machines function as both clients and servers. In
        such cases, the machine would need a DNS name for its use
        as a server. Whether the address stays fixed or changes has
        little privacy implication since the DNS name remains
        constant and serves as a constant identifier. When acting
        as a client (e.g., initiating communication), however, such
        a machine may want to vary the addresses it uses. In such
        environments, one may need multiple addresses: a stable 
        address registered in the DNS, that is used to accept 
		incoming connection requests from
        other machines, and a temporary address used to shield
        the identity of the client when it initiates communication.
        <!-- These two cases are roughly analogous to telephone numbers
        and caller ID, where a user may list their telephone number
        in the public phone book, but disable the display of its
        number via caller ID when initiating calls.--></t>

		<t>On the other hand, a machine that functions only as a 
           client may want to employ only temporary addresses for
           public communication.</t>

        <t>To make it difficult to make educated guesses as to
        whether two different interface identifiers belong to the
        same node, the algorithm for generating alternate
        identifiers must include input that has an unpredictable
        component from the perspective of the outside entities that
        are collecting information.</t>

<!--
		<t><xref target="I-D.gont-6man-non-stable-iids"/> specifies
        requirements for temporary addresses. This document specifies
        a number of algorithms for generating temporary addresses that comply
        with the aforementioned requirements.</t>
-->        
<!--
		<t>Picking identifiers from a
        pseudo-random sequence suffices, so long as the specific
        sequence cannot be determined by an outsider examining
        information that is readily available or easily
        determinable (e.g., by examining packet contents). This
        document proposes the generation of a pseudo-random
        sequence of interface identifiers via an MD5 hash.
        Periodically, the next interface identifier in the sequence
        is generated, a new set of temporary addresses is created,
        and the previous temporary addresses are deprecated to
        discourage their further use. The precise pseudo-random
        sequence depends on both a random component and the
        globally unique interface identifier (when available), to
        increase the likelihood that different nodes generate
        different sequences.</t>
-->
      </section>
    </section>

    <section anchor="SECTION3" title="Protocol Description">
      <t>The goal of this section is to define procedures that can generate IPv6 addresses with the following properties:</t>
      <t>
        <list style="numbers">
          <t>Temporary addresses can be employed for initiating
          outgoing sessions.</t>

<t>Temporary addresses
          are used for a short period of time (typically hours to days)
          and are subsequently deprecated. Deprecated addresses can
          continue to be used for already established connections,
          but are not used to initiate new connections. </t>

<t>New
          temporary addresses are generated periodically to replace
          temporary addresses that expire.</t>

<t>Temporary addresses must have a limited lifetime (limited "valid lifetime" and "preferred lifetime" from <xref target="RFC4862"/>), that should be statistically different for different addresses. The lifetime of an address should be further reduced when privacy-meaningful events (such as a node attaching to a different network, or the regeneration of a new randomized MAC address) takes place.</t>


          <t>By default, one address is generated for each
          prefix advertised for stateless address autoconfiguration. The resulting Interface Identifiers must be statistically different when addresses are configured 
   for different prefixes.  That is, when temporary addresses are generated for different
   autoconfiguration prefixes for the same network interface, the resulting Interface Identifiers must be
   statistically different.  This means that, given two addresses that employ different prefixes, it must
   be difficult for an outside entity to tell whether the addresses correspond to the same network interface or even whether they have been
   generated by the same host.
</t>


<t>It must be difficult for an outside entity to predict the Interface
   Identifiers that will be employed for temporary addresses, even with knowledge
   of the algorithm/method employed to generate them and/or knowledge of the Interface Identifiers previously employed for other temporary addresses. These Interface Identifiers must be semantically opaque <xref target="RFC7136"/> and must not follow any specific patterns.</t>

</list> 
</t>



      <section title="Assumptions">
<!--
        <t>The following algorithm assumes that each interface
        maintains an associated randomized interface identifier.
        When temporary addresses are generated, the current value
        of the associated randomized interface identifier is used.
        While the same identifier can be used to create more than
        one temporary address, the value SHOULD change over time as
        described in 
        <xref target='REGEN' />.</t>
-->
        <t>The following algorithm assumes that for a given temporary
        address, an implementation can determine the prefix from
        which it was generated. When a temporary address is
        deprecated, a new temporary address is generated. The
        specific valid and preferred lifetimes for the new address
        are dependent on the corresponding lifetime values set for
        the prefix from which it was generated.</t>
        <t>Finally, this document assumes that when a node
        initiates outgoing communication, temporary addresses can
        be given preference over stable addresses (if available), when the device
        is configured to do so. 
        <xref target='RFC6724' /> mandates implementations to
        provide a mechanism, which allows an application to
        configure its preference for temporary addresses over
        stable addresses. It also allows for an implementation to
        prefer temporary addresses by default, so that the
        connections initiated by the node can use temporary
        addresses without requiring application-specific
        enablement. This document also assumes that an API will
        exist that allows individual applications to indicate
        whether they prefer to use temporary or stable addresses
        and override the system defaults. 
   </t>
      </section>



      <section anchor="SECTION3_2"
      title="Generation of Randomized Interface Identifiers">

<t>The following subsections specify some possible algorithms for generating temporary interface identifiers that follow the guidelines in <xref target="SECTION3"/> of this document. The algorithm specified in <xref target="randomized-IIDs"/> benefits from a Pseudo-Random Number Generator (PRNG) available on the system. On the other hand, the algorithm specified in <xref target="RFC-7217"/> allows for code reuse by nodes that implement <xref target="RFC7217"/>.

<!--<xref target="traditional"/> specifies the traditional algorithm for generating randomized interface identifiers. <xref target="RFC-7217"/> and <xref target="randomized-IIDs"/> specify other possible algorithms.--></t>



<section title="Simple Randomized Interface Identifiers" anchor="randomized-IIDs">
<t>One possible approach would be to select a pseudorandom number of the appropriate length. A node employing this algorithm should generate IIDs as follows:

<list style="numbers">
<t>Obtain a random number (see <xref target="RFC4086"/> for randomness requirements for
 security)</t>

<t>The Interface Identifier is obtained by taking as many bits from the aforementioned random number (obtained in the previous step) as necessary. Note: there are no special bits in an Interface Identifier <xref target="RFC7136"/>.

<list style="hanging">
<t>We note that <xref target="RFC4291"/> requires that the Interface
  IDs of all unicast addresses (except those that start with the
  binary value 000) be 64 bits long. However, the method discussed in this document could be employed for generating Interface IDs of any arbitrary length, albeit at the expense of reduced entropy (when employing Interface IDs smaller than 64 bits).</t>
</list>
</t>

<t>
The resulting Interface Identifier SHOULD be compared against the reserved IPv6 Interface Identifiers <xref target="RFC5453"/> <xref target="IANA-RESERVED-IID"/> and against those Interface Identifiers already employed in an address of the same network interface and the same network prefix. In the event that an unacceptable identifier has been generated, a new interface identifier should be generated, by repeating the algorithm from the first step.
</t>
</list>
</t>

 

</section>
<section title="Hash-based Generation of Randomized Interface Identifiers" anchor="RFC-7217">

<t>The algorithm in <xref target="RFC7217"/> can be augmented for the generation of temporary addresses. The benefit of this would be that a node could employ a single algorithm for generating stable and temporary addresses, by employing appropriate parameters.</t>

<t>Nodes would employ the following algorithm for generating the temporary IID:

<list style="numbers">
<t>
Compute a random identifier with the expression:
<vspace blankLines="1" />
RID = F(Prefix, MAC_Address, Network_ID, Time, DAD_Counter, secret_key)
<vspace blankLines="1" />
Where:
<list style="hanging">
<t hangText="RID:">
<vspace blankLines="0" />Random Identifier</t>
<t hangText="F():">
<vspace blankLines="0" />A pseudorandom function (PRF) that MUST NOT be computable from the outside (without knowledge of the secret key). F() MUST also be difficult to reverse, such that it resists attempts to obtain the secret_key, even when given samples of the output of F() and knowledge
or control of the other input parameters. F() SHOULD produce an output of at least 64 bits. F() could be implemented as a cryptographic hash of the concatenation of each of the function parameters. SHA-1 <xref target="FIPS-SHS"/> and SHA-256 are two possible options for F(). Note: MD5 <xref target="RFC1321"/> is considered unacceptable for F() <xref target="RFC6151"/>.</t>
<t hangText="Prefix:">
<vspace blankLines="0" />The prefix to be used for SLAAC, as learned from an ICMPv6 Router Advertisement message.</t>
<t hangText="MAC_Address:">
<vspace blankLines="0" />The MAC address corresponding to the underlying network interface card. Employing the MAC address in this expression (in replacement of the Net_Iface parameter of the expression in RFC7217) means that the re-generation of a randomized MAC address will result in a different temporary address.</t>
<t hangText="Network_ID:">
<vspace blankLines="0" />Some network-specific data that identifies
the subnet to which this interface is attached -- for example, the IEEE 802.11 Service Set Identifier (SSID) corresponding to the network to which this interface is associated. Additionally, Simple DNA <xref target="RFC6059"/> describes ideas that could be leveraged to generate a Network_ID parameter. This parameter is SHOULD be employed if some form of "Network_ID" is available.</t>
<t hangText="Time:">
<vspace blankLines="0" />An implementation-dependent representation of time. One possible example is the representation in UNIX-like systems <xref target="OPEN-GROUP"/>, that measure time in terms of the number of seconds elapsed since the Epoch (00:00:00 Coordinated Universal Time (UTC), 1 January 1970).</t>

<t hangText="DAD_Counter:">
<vspace blankLines="0" />A counter that is employed to resolve Duplicate Address Detection (DAD) conflicts.<!-- It MUST be initialized to 0, and incremented by 1 for each new tentative address that is configured as a result of a DAD conflict. Implementations that record DAD_Counter in non-volatile memory for each {Prefix, Net_Iface, Network_ID} tuple MUST initialize DAD_Counter to the recorded value if such an entry exists in non-volatile memory. See <xref target="dad-conflicts"/> for additional details.--></t>
<t hangText="secret_key:">
<vspace blankLines="0" />A secret key that is not known by the
 attacker. The secret key SHOULD be of at least 128 bits. It MUST be initialized to a pseudo-random number
 (see <xref target="RFC4086"/> for randomness requirements for
 security) when the operating system is "bootstrapped".


<!-- An implementation MAY provide the means for the system administrator to display and change the secret key. -->
</t>
</list>
</t>

<t>The Interface Identifier is finally obtained by taking as many bits from the RID value (computed in the previous step) as necessary, starting from the least significant bit.<!--
<list style="hanging">
<t>We note that <xref target="RFC4291"/> requires that the Interface
  IDs of all unicast addresses (except those that start with the
  binary value 000) be 64 bits long. However, the method discussed in this document could be employed for generating Interface IDs of any arbitrary length, albeit at the expense of reduced entropy (when employing Interface IDs smaller than 64 bits).</t>
</list>-->
The resulting Interface Identifier SHOULD be compared against the reserved IPv6 Interface Identifiers <xref target="RFC5453"/> <xref target="IANA-RESERVED-IID"/> and against those Interface Identifiers already employed in an address of the same network interface and the same network prefix. In the event that an unacceptable identifier has been generated, the value DAD_Counter should be incremented by 1, and the algorithm should be restarted from the first step.
</t>
</list>
</t>

</section>

      </section>


<!-- </section> -->




      <section anchor="SECTION3_3"
      title="Generating Temporary Addresses">
        <t>
        <xref target='RFC4862' /> describes the steps for
        generating a link-local address when an interface becomes
        enabled as well as the steps for generating addresses for
        other scopes. This document extends 
        <xref target='RFC4862' /> as follows. When processing a
        Router Advertisement with a Prefix Information option
        carrying a global scope prefix for the purposes of address
        autoconfiguration (i.e., the A bit is set), the node MUST
        perform the following steps:</t>
        <t>
<!-- XXX: The I-D version said (TEMP_VALID_LIFETIME - DESYNC_FACTOR) -->
          <list style="numbers">
            <t>Process the Prefix Information Option as defined in 
            <xref target='RFC4862' />, adjusting the lifetimes of existing
            temporary addresses. If a received
            option may extend the lifetimes of temporary addresses, with the overall constraint that no
            temporary addresses should ever remain "valid" or
            "preferred" for a time longer than (TEMP_VALID_LIFETIME)
			or (TEMP_PREFERRED_LIFETIME -
            DESYNC_FACTOR) respectively. The configuration
            variables TEMP_VALID_LIFETIME and
            TEMP_PREFERRED_LIFETIME correspond to approximate
            target lifetimes for temporary addresses.</t>
            <t>One way an implementation can satisfy the above
            constraints is to associate with each temporary address
            a creation time (called CREATION_TIME) that indicates
            the time at which the address was created. When
            updating the preferred lifetime of an existing
            temporary address, it would be set to expire at
            whichever time is earlier: the time indicated by the
            received lifetime or (CREATION_TIME +
            TEMP_PREFERRED_LIFETIME - DESYNC_FACTOR). A similar
            approach can be used with the valid lifetime.</t>
           


			 <t>If the node has not configured any temporary address for the corresponding prefix, the node SHOULD create
            a new temporary address for such prefix.</t>
            <t>When creating a temporary address, the lifetime
            values MUST be derived from the corresponding prefix as
            follows: 
            <list style="symbols">
              <t>Its Valid Lifetime is the lower of the Valid
              Lifetime of the prefix and TEMP_VALID_LIFETIME</t>
              <t>Its Preferred Lifetime is the lower of the
              Preferred Lifetime of the prefix and
              TEMP_PREFERRED_LIFETIME - DESYNC_FACTOR.</t>
            </list></t>
            <t>A temporary address is created only if this
            calculated Preferred Lifetime is greater than
            REGEN_ADVANCE time units. In particular, an
            implementation MUST NOT create a temporary address with
            a zero Preferred Lifetime.</t>
            <t>New temporary addresses MUST be created by appending
            a randomized interface identifier (generates as described in <xref target="SECTION3_2"/> of this document) to the prefix that was received.</t>
            <t>The node MUST perform duplicate address detection
            (DAD) on the generated temporary address. If DAD
            indicates the address is already in use, the node MUST
            generate a new randomized interface identifier<!-- as
            described in 
            <xref target='SECTION3_2' /> above-->, and repeat the
            previous steps as appropriate up to TEMP_IDGEN_RETRIES
            times. If after TEMP_IDGEN_RETRIES consecutive attempts
            no non-unique address was generated, the node MUST log
            a system error and MUST NOT attempt to generate
            temporary addresses for that interface. Note that DAD
            MUST be performed on every unicast address generated
            from this randomized interface identifier.</t>
          </list>
        </t>
      </section>
      <section anchor="SECTION3_4"
      title="Expiration of Temporary Addresses">
        <t>When a temporary address becomes deprecated, a new one
        MUST be generated. This is done by repeating the actions
        described in 
        <xref target='SECTION3_3' />, starting at step 4). Note
        that, except for the transient period when a temporary
        address is being regenerated, in normal operation at most
        one temporary address per prefix should be in a
        non-deprecated state at any given time on a given
        interface. Note that if a temporary address becomes
        deprecated as result of processing a Prefix Information
        Option with a zero Preferred Lifetime, then a new temporary
        address MUST NOT be generated. To ensure that a preferred
        temporary address is always available, a new temporary
        address SHOULD be regenerated slightly before its
        predecessor is deprecated. This is to allow sufficient time
        to avoid race conditions in the case where generating a new
        temporary address is not instantaneous, such as when
        duplicate address detection must be run. The node SHOULD
        start the address regeneration process REGEN_ADVANCE time
        units before a temporary address would actually be
        deprecated.</t>
        <t>As an optional optimization, an implementation MAY
        remove a deprecated temporary address that is not in use by
        applications or upper layers as detailed in 
        <xref target='SECTION6' />.</t>
      </section>
      <section anchor="REGEN"
      title="Regeneration of Temporary Addresses">
        <t>The frequency at which temporary addresses change
        depends on how a device is being used (e.g., how frequently
        it initiates new communication) and the concerns of the end
        user. The most egregious privacy concerns appear to involve
        addresses used for long periods of time (weeks to months to
        years). The more frequently an address changes, the less
        feasible collecting or coordinating information keyed on
        interface identifiers becomes. Moreover, the cost of
        collecting information and attempting to correlate it based
        on interface identifiers will only be justified if enough
        addresses contain non-changing identifiers to make it
        worthwhile. Thus, having large numbers of clients change
        their address on a daily or weekly basis is likely to be
        sufficient to alleviate most privacy concerns.</t>
        <t>There are also client costs associated with having a
        large number of addresses associated with a node (e.g., in
        doing address lookups, the need to join many multicast
        groups, etc.). Thus, changing addresses frequently (e.g.,
        every few minutes) may have performance implications.</t>
        <t>Nodes following this specification SHOULD generate new
        temporary addresses on a periodic basis. This can be
        achieved by generating a new temporary address 
        at least once every
        (TEMP_PREFERRED_LIFETIME - REGEN_ADVANCE - DESYNC_FACTOR)
        time units. As described above, generating a new temporary
        address REGEN_ADVANCE time units before a temporary address
        becomes deprecated produces addresses with a preferred
        lifetime no larger than TEMP_PREFERRED_LIFETIME. The value
        DESYNC_FACTOR is a random value (different for each client)
        that ensures that clients don't synchronize with each other
        and generate new addresses at exactly the same time. When
        the preferred lifetime expires, a new temporary address
        MUST be generated using the new randomized interface
        identifier.</t>
        <t>Because the precise frequency at which it is appropriate
        to generate new addresses varies from one environment to
        another, implementations SHOULD provide end users with the
        ability to change the frequency at which addresses are
        regenerated. The default value is given in
        TEMP_PREFERRED_LIFETIME and is one day. In addition, the
        exact time at which to invalidate a temporary address
        depends on how applications are used by end users. Thus,
        the suggested default value of one week
        (TEMP_VALID_LIFETIME) may not be appropriate in all
        environments. Implementations SHOULD provide end users with
        the ability to override both of these default values.</t>
        <t>Finally, when an interface connects to a new (different) link, a new set 
        of temporary addresses MUST be generated immediately.
        If a device moves from one ethernet to another, generating
        a new set of temporary addresses ensures that the device
        uses different randomized interface identifiers for the
        temporary addresses associated with the two links, making
        it more difficult to correlate addresses from the two
        different links as being from the same node. The node MAY
        follow any process available to it, to determine that the
        link change has occurred. One such process is described by "Simple Procedures for Detecting Network Attachment in IPv6" <xref target='RFC6059' />. Detecting link changes would prevent link down/up events from causing temporary addresses to be (unnecessarily) regenerated.</t>
      </section>
      <section title="Deployment Considerations">
        <t>Devices implementing this specification MUST provide a
        way for the end user to explicitly enable or disable the
        use of temporary addresses. In addition, a site might wish
        to disable the use of temporary addresses in order to
        simplify network debugging and operations. Consequently,
        implementations SHOULD provide a way for trusted system
        administrators to enable or disable the use of temporary
        addresses.</t>
        <t>Additionally, sites might wish to selectively enable or
        disable the use of temporary addresses for some prefixes.
        For example, a site might wish to disable temporary address
        generation for "Unique local" 
        <xref target='RFC4193' /> prefixes while still generating
        temporary addresses for all other global prefixes. Another
        site might wish to enable temporary address generation only
        for the prefixes 2001::/16 and 2002::/16 while disabling it
        for all other prefixes. To support this behavior,
        implementations SHOULD provide a way to enable and disable
        generation of temporary addresses for specific prefix
        subranges. This per-prefix setting SHOULD override the
        global settings on the node with respect to the specified
        prefix subranges. Note that the per-prefix setting can be
        applied at any granularity, and not necessarily on a per
        subnet basis.</t>
        <t>The use of temporary addresses may cause unexpected
        difficulties with some applications. As described below,
        some servers refuse to accept communications from clients
        for which they cannot map the IP address into a DNS name.
        In addition, some applications may not behave robustly if
        temporary addresses are used and an address expires before
        the application has terminated, or if it opens multiple
        sessions, but expects them to all use the same addresses.
<!--
        Consequently, the use of temporary addresses SHOULD be
        disabled by default in order to minimize potential
        disruptions. Individual applications, which have specific
        knowledge about the normal duration of connections, MAY
        override this as appropriate.--></t>
        <t>If a very small number of nodes (say, only one) use a
        given prefix for extended periods of time, just changing
        the interface identifier part of the address may not be
        sufficient to ensure privacy, since the prefix acts as a
        constant identifier. The procedures described in this
        document are most effective when the prefix is reasonably
        non static or is used by a fairly large number of
        nodes.</t>
      </section>
    </section>



    <section anchor="SECTION4"
    title="Implications of Changing Interface Identifiers">
<!--      <t>The IPv6 addressing architecture goes to some lengths to
      ensure that interface identifiers are likely to be globally
      unique where easy to do so. The widespread use of temporary
      addresses may result in a significant fraction of Internet
      traffic not using addresses in which the interface identifier
      portion is globally unique. Consequently, usage of the
      algorithms in this document may complicate providing such a
      future flexibility, if global uniqueness is necessary.</t>
-->
      <t>The desires of protecting individual privacy versus the
      desire to effectively maintain and debug a network can
      conflict with each other. Having clients use addresses that
      change over time will make it more difficult to track down
      and isolate operational problems. For example, when looking
      at packet traces, it could become more difficult to determine
      whether one is seeing behavior caused by a single errant
      machine, or by a number of them.</t>

      <t>Some servers refuse to grant access to clients for which
      no DNS name exists. That is, they perform a DNS PTR query to
      determine the DNS name, and may then also perform an AAAA
      query on the returned name to verify that the returned DNS
      name maps back into the address being used. Consequently,
      clients not properly registered in the DNS may be unable to
      access some services. As noted earlier, however, a node's DNS
      name (if non-changing) serves as a constant identifier. The
      wide deployment of the extension described in this document
      could challenge the practice of inverse-DNS-based
      "authentication," which has little validity, though it is
      widely implemented. In order to meet server challenges, nodes
      could register temporary addresses in the DNS using random
      names (for example, a string version of the random address
      itself).</t>
      <t>Use of the extensions defined in this document may
      complicate debugging and other operational troubleshooting
      activities. Consequently, it may be site policy that
      temporary addresses should not be used. Consequently,
      implementations MUST provide a method for the end user or
      trusted administrator to override the use of temporary
      addresses.</t>
    </section>

<!--
   <vspace blankLines="100" /> -->
    <section title="Defined Constants">
      <t>Constants defined in this document include:</t>
      <t>TEMP_VALID_LIFETIME -- Default value: 1 week. Users should
      be able to override the default value.</t>
      <t>TEMP_PREFERRED_LIFETIME -- Default value: 1 day. Users
      should be able to override the default value.</t>
      <t>REGEN_ADVANCE -- 5 seconds</t>
      <t>MAX_DESYNC_FACTOR -- 10 minutes. Upper bound on
      DESYNC_FACTOR.</t>
      <t>DESYNC_FACTOR -- A random value within the range 0 -
      MAX_DESYNC_FACTOR. It is computed once at system start
      (rather than each time it is used) and must never be greater
      than (TEMP_PREFERRED_LIFETIME - REGEN_ADVANCE).</t>
      <t>TEMP_IDGEN_RETRIES -- Default value: 3</t>
    </section>
    <section anchor="SECTION6" title="Future Work">
      <t>An implementation might want to keep track of which
      addresses are being used by upper layers so as to be able to
      remove a deprecated temporary address from internal data
      structures once no upper layer protocols are using it (but
      not before). This is in contrast to current approaches where
      addresses are removed from an interface when they become
      invalid 
      <xref target='RFC4862' />, independent of whether or not
      upper layer protocols are still using them. For TCP
      connections, such information is available in control blocks.
      For UDP-based applications, it may be the case that only the
      applications have knowledge about what addresses are actually
      in use. Consequently, an implementation generally will need
      to use heuristics in deciding when an address is no longer in
      use.</t>

      <t><!--The determination as to whether to use stable versus
      temporary addresses can in some cases only be made by an
      application. For example, some applications may always want
      to use temporary addresses, while others may want to use them
      only in some circumstances or not at all. Suitable API
      extensions will likely need to be developed to enable
      individual applications to indicate with sufficient
      granularity their needs with regards to the use of temporary
      addresses.--> Recommendations on DNS practices to avoid the
      problem described in 
      <xref target='SECTION4' /> when reverse DNS lookups fail may
      be needed. 
      <xref target='RFC4472' /> contains a more detailed discussion of
      the DNS-related issues.</t>
      <t>While this document discusses ways of obscuring a user's
      IP address, the method described is believed to be
      ineffective against sophisticated forms of traffic analysis.
      To increase effectiveness, one may need to consider use of
      more advanced techniques, such as Onion Routing 
      <xref target='ONION' />.</t>
    </section>



    <section title="Security Considerations">
      <t>Ingress filtering has been and is being deployed as a
      means of preventing the use of spoofed source addresses in
      Distributed Denial of Service (DDoS) attacks. In a network
      with a large number of nodes, new temporary addresses are
      created at a fairly high rate. This might make it difficult
      for ingress filtering mechanisms to distinguish between
      legitimately changing temporary addresses and spoofed source
      addresses, which are "in-prefix" (using a topologically
      correct prefix and non-existent interface ID). This can be
      addressed by using access control mechanisms on a per-address
      basis on the network egress point.</t>
    </section>

    <section title="Significant Changes from RFC4941">
      <t>This section summarizes the changes in this document
      relative to RFC 4941 that an implementer of RFC 4941 should
      be aware of. 
      <list style="numbers">
		<t>Discussion of IEEE-based IIDs has been removed, since the current recommendation (<xref target="RFC8064"/>) is to employ <xref target="RFC7217"/>).</t>
		<t>The document employs the terminology from <xref target="RFC7721"/>.</t>
		<t>Sections 2.2 and 2.3 of <xref target="RFC4941"/> have been removed since the topic has been discussed in more detail in e.g. <xref target="RFC7721"/>.</t>
        <t>The algorithm specified in Section 3.2.1 and 3.2.2 of <xref target="RFC4941"/> was replaced by two possible alternative algorithms.</t>
		<t>Generation of stable addresses is not implied or required by this document.</t>
        <t>Temporary addresses are *not* disabled by default.</t>

		<t>Section 3.2.3 from <xref target="RFC4941"/> was removed, based on the explanation of that very section of RFC4941.</t>
		<t>All the verified errata for <xref target="RFC4941"/> has been incorporated.</t>
      </list></t>
    </section>

<section title="Acknowledgments">
<t>The authors would like to thank (in alphabetical order) Brian Carpenter, Tim Chown, Lorenzo Colitti, David Farmer, Tom Herbert, Bob Hinden, Christian Huitema, Dave Plonka, Michael Richardson, Mark Smith, and Johanna Ullrich for providing valuable comments on earlier versions of this document.</t>

<t>This document incoporates errata submitted for <xref target="RFC4941"/> by (in alphabetical order) Jiri Bohac and Alfred Hoenes.</t>

      <t>This document is based on <xref target="RFC4941"/> (a revision of RFC3041). Suresh Krishnan was the sole author of RFC4941. He would like to acknowledge the contributions of the ipv6 working
   group and, in particular, Jari Arkko, Pekka Nikander, Pekka Savola,
   Francis Dupont, Brian Haberman, Tatuya Jinmei, and Margaret Wasserman
   for their detailed comments.</t>
<t>
   Rich Draves and Thomas Narten were the authors of RFC 3041.  They
   would like to acknowledge the contributions of the ipv6 working group
   and, in particular, Ran Atkinson, Matt Crawford, Steve Deering,
   Allison Mankin, and Peter Bieringer.
</t>
    </section>

  </middle>
  <back>

    <references title="Normative References">
<!-- XXX: A ser eliminados 
	<?rfc include="reference.RFC.4861" ?>
	<?rfc include="reference.RFC.3971" ?>
	<?rfc include="reference.RFC.3972" ?>
	<?rfc include="reference.RFC.2526" ?>
-->
<!-- XXX: Fin de a ser eliminados -->


<!-- Source Address Selection -->
	<?rfc include="reference.RFC.6724" ?>


<!-- Added as a result of algorithm specification -->
	<?rfc include="reference.RFC.4086" ?>
	<?rfc include="reference.RFC.5453" ?>
	<?rfc include="reference.RFC.7136" ?> 
	<?rfc include="reference.RFC.8064" ?>

	<?rfc include="reference.RFC.7217" ?>
	<?rfc include="reference.RFC.4941" ?>

	<?rfc include="reference.RFC.2119" ?>
	<?rfc include="reference.RFC.8174" ?>
	<?rfc include="reference.RFC.8190" ?>

	<?rfc include="reference.RFC.4193" ?>
	<?rfc include="reference.RFC.4291" ?>


	<?rfc include="reference.RFC.4862" ?>
	</references>





    <references title="Informative References">

<!-- widespread encryption -->

	<?rfc include="reference.RFC.7624" ?>

<!-- Source Address Selection API -->
	<?rfc include="reference.RFC.5014" ?>

	<reference anchor="IANA-RESERVED-IID" target="http://www.iana.org/assignments/ipv6-interface-ids">
		<front>
			<title>Reserved IPv6 Interface Identifiers</title>
			<author>
				<organization>IANA</organization>
			</author>
			<date/>
		</front>
	</reference>

	<?rfc include="reference.RFC.1321" ?>
	<?rfc include="reference.RFC.6151" ?>

	<reference anchor="FIPS-SHS" target="http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf">
		<front>
			<title>Secure Hash Standard (SHS)</title>

    <author>
		<organization>NIST</organization>
    </author>  

			<date month="March" year="2012"/>
		</front>
		<seriesInfo name="FIPS Publication" value="180-4"/>
	</reference>

	<reference anchor="OPEN-GROUP" target="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/contents.html">
		<front>
			<title>The Open Group Base Specifications Issue 7 / IEEE Std 1003.1-2008, 2016 Edition</title>

    <author>
		<organization>The Open Group</organization>
    </author>  

			<date year="2016"/>
		</front>
		<seriesInfo name="Section 4.16" value="Seconds Since the Epoch"/>
	</reference>

	<!-- RFC6265 -->
	<?rfc include="reference.RFC.6265" ?>



	<!-- DHCPv6 -->
	<?rfc include="reference.RFC.8415" ?>

<!-- Dynamic DNS -->
<!--
	<?rfc include="reference.RFC.2136" ?>
-->

	<?rfc include="reference.RFC.7721" ?>

	<?rfc include="reference.RFC.7707" ?>

      <reference anchor='ONION'>
        <front>
          <title>Proxies for Anonymous Routing</title>
          <author initials='MGR' surname='Reed'
          fullname='Michael G. Reed'>
            <organization />
          </author>
          <author initials='PFS' surname='Syverson'
          fullname='Paul F. Syverson'>
            <organization />
          </author>
          <author initials='DMG' surname='Goldschlag'
          fullname='David M. Goldschlag'>
            <organization />
          </author>
          <date month='December' year='1996' />
        </front>
        <seriesInfo name=''
        value='Proceedings of the 12th Annual Computer Security Applications Conference, San Diego, CA' />
      </reference>


<!--	<?rfc include="reference.I-D.gont-6man-non-stable-iids" ?> -->
<!--
	<?rfc include="reference.I-D.gont-taps-address-usage-problem-statement" ?> 
-->


<!-- DNA -->
	<?rfc include="reference.RFC.6059" ?>



<!-- DNSOP -->
	<?rfc include="reference.RFC.4472" ?>


    </references>

  </back>
</rfc>
<!--
Local Variables:
mode:xml
End:
=-->
