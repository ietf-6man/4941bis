<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Privacy Extensions for Stateless Address Autoconfiguration in IPv6</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
      /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
      a.info {
          /* This is the key. */
          position: relative;
          z-index: 24;
          text-decoration: none;
      }
      a.info:hover {
          z-index: 25;
          color: #FFF; background-color: #900;
      }
      a.info span { display: none; }
      a.info:hover span.info {
          /* The span will display just on :hover state. */
          display: block;
          position: absolute;
          font-size: smaller;
          top: 2em; left: -5em; width: 15em;
          padding: 2px; border: 1px solid #333;
          color: #900; background-color: #EEE;
          text-align: left;
      }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  max-width: 55em;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Terminology">
<link href="#rfc.section.1.2" rel="Chapter" title="1.2 Problem Statement">
<link href="#rfc.section.2" rel="Chapter" title="2 Background">
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 Extended Use of the Same Identifier">
<link href="#rfc.section.2.2" rel="Chapter" title="2.2 Possible Approaches">
<link href="#rfc.section.3" rel="Chapter" title="3 Protocol Description">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Assumptions">
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Generation of Randomized Interface Identifiers">
<link href="#rfc.section.3.2.1" rel="Chapter" title="3.2.1 Simple Randomized Interface Identifiers">
<link href="#rfc.section.3.2.2" rel="Chapter" title="3.2.2 Hash-based Generation of Randomized Interface Identifiers">
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 Generating Temporary Addresses">
<link href="#rfc.section.3.4" rel="Chapter" title="3.4 Expiration of Temporary Addresses">
<link href="#rfc.section.3.5" rel="Chapter" title="3.5 Regeneration of Temporary Addresses">
<link href="#rfc.section.3.6" rel="Chapter" title="3.6 Implementation Considerations">
<link href="#rfc.section.4" rel="Chapter" title="4 Implications of Changing Interface Identifiers">
<link href="#rfc.section.5" rel="Chapter" title="5 Defined Constants">
<link href="#rfc.section.6" rel="Chapter" title="6 Future Work">
<link href="#rfc.section.7" rel="Chapter" title="7 Security Considerations">
<link href="#rfc.section.8" rel="Chapter" title="8 Significant Changes from RFC4941">
<link href="#rfc.section.9" rel="Chapter" title="9 Acknowledgments">
<link href="#rfc.references" rel="Chapter" title="10 References">
<link href="#rfc.references.1" rel="Chapter" title="10.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="10.2 Informative References">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.35.0 - https://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Gont, F., Krishnan, S., Narten, T., and R. Draves" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-ietf-6man-rfc4941bis-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2020-27" />
  <meta name="dct.abstract" content="Nodes use IPv6 stateless address autoconfiguration to generate addresses using a combination of locally available information and information advertised by routers. Addresses are formed by combining network prefixes with an interface identifier. This document describes an extension that causes nodes to generate global scope addresses with randomized interface identifiers that change over time. Changing global scope addresses over time makes it more difficult for eavesdroppers and other information collectors to identify when different addresses used in different transactions correspond to the same node. This document obsoletes RFC4941." />
  <meta name="description" content="Nodes use IPv6 stateless address autoconfiguration to generate addresses using a combination of locally available information and information advertised by routers. Addresses are formed by combining network prefixes with an interface identifier. This document describes an extension that causes nodes to generate global scope addresses with randomized interface identifiers that change over time. Changing global scope addresses over time makes it more difficult for eavesdroppers and other information collectors to identify when different addresses used in different transactions correspond to the same node. This document obsoletes RFC4941." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">IPv6 Maintenance (6man) Working Group</td>
<td class="right">F. Gont</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">SI6 Networks / UTN-FRH</td>
</tr>
<tr>
<td class="left">Obsoletes: rfc4941 (if approved)</td>
<td class="right">S. Krishnan</td>
</tr>
<tr>
<td class="left">Intended status: Standards Track</td>
<td class="right">Ericsson Research</td>
</tr>
<tr>
<td class="left">Expires: July 30, 2020</td>
<td class="right">T. Narten</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">IBM Corporation</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">R. Draves</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Microsoft Research</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">January 27, 2020</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Privacy Extensions for Stateless Address Autoconfiguration in IPv6<br />
  <span class="filename">draft-ietf-6man-rfc4941bis-latest</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>Nodes use IPv6 stateless address autoconfiguration to generate addresses using a combination of locally available information and information advertised by routers. Addresses are formed by combining network prefixes with an interface identifier. This document describes an extension that causes nodes to generate global scope addresses with randomized interface identifiers that change over time. Changing global scope addresses over time makes it more difficult for eavesdroppers and other information collectors to identify when different addresses used in different transactions correspond to the same node. This document obsoletes RFC4941.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on July 30, 2020.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2020 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<ul><li>1.1.   <a href="#rfc.section.1.1">Terminology</a>
</li>
<li>1.2.   <a href="#rfc.section.1.2">Problem Statement</a>
</li>
</ul><li>2.   <a href="#rfc.section.2">Background</a>
</li>
<ul><li>2.1.   <a href="#rfc.section.2.1">Extended Use of the Same Identifier</a>
</li>
<li>2.2.   <a href="#rfc.section.2.2">Possible Approaches</a>
</li>
</ul><li>3.   <a href="#rfc.section.3">Protocol Description</a>
</li>
<ul><li>3.1.   <a href="#rfc.section.3.1">Assumptions</a>
</li>
<li>3.2.   <a href="#rfc.section.3.2">Generation of Randomized Interface Identifiers</a>
</li>
<ul><li>3.2.1.   <a href="#rfc.section.3.2.1">Simple Randomized Interface Identifiers</a>
</li>
<li>3.2.2.   <a href="#rfc.section.3.2.2">Hash-based Generation of Randomized Interface Identifiers</a>
</li>
</ul><li>3.3.   <a href="#rfc.section.3.3">Generating Temporary Addresses</a>
</li>
<li>3.4.   <a href="#rfc.section.3.4">Expiration of Temporary Addresses</a>
</li>
<li>3.5.   <a href="#rfc.section.3.5">Regeneration of Temporary Addresses</a>
</li>
<li>3.6.   <a href="#rfc.section.3.6">Implementation Considerations</a>
</li>
</ul><li>4.   <a href="#rfc.section.4">Implications of Changing Interface Identifiers</a>
</li>
<li>5.   <a href="#rfc.section.5">Defined Constants</a>
</li>
<li>6.   <a href="#rfc.section.6">Future Work</a>
</li>
<li>7.   <a href="#rfc.section.7">Security Considerations</a>
</li>
<li>8.   <a href="#rfc.section.8">Significant Changes from RFC4941</a>
</li>
<li>9.   <a href="#rfc.section.9">Acknowledgments</a>
</li>
<li>10.   <a href="#rfc.references">References</a>
</li>
<ul><li>10.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>10.2.   <a href="#rfc.references.2">Informative References</a>
</li>
</ul><li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#intro" id="intro">Introduction</a>
</h1>
<p id="rfc.section.1.p.1">Stateless address autoconfiguration (SLAAC) <a href="#RFC4862" class="xref">[RFC4862]</a> defines how an IPv6 node generates addresses without the need for a Dynamic Host Configuration Protocol for IPv6 (DHCPv6) server. The security and privacy implications of such addresses have been discussed in great detail in <a href="#RFC7721" class="xref">[RFC7721]</a>,<a href="#RFC7217" class="xref">[RFC7217]</a>, and RFC7707. This document specifies an extension for SLAAC to generate temporary addresses, such that the aforementioned issues are mitigated.</p>
<p id="rfc.section.1.p.2">The default address selection for IPv6 has been specified in <a href="#RFC6724" class="xref">[RFC6724]</a>. The determination as to whether to use stable versus temporary addresses can in some cases only be made by an application. For example, some applications may always want to use temporary addresses, while others may want to use them only in some circumstances or not at all. An API such as that specified in <a href="#RFC5014" class="xref">[RFC5014]</a> can enable individual applications to indicate a preference for the use of temporary addresses.  </p>
<p><a href="#SECTION2" class="xref">Section 2</a> provides background information on the issue.  <a href="#SECTION3" class="xref">Section 3</a> describes a procedure for generating temporary interface identifiers and global scope addresses.  <a href="#SECTION4" class="xref">Section 4</a> discusses implications of changing interface identifiers.  </p>
<h1 id="rfc.section.1.1">
<a href="#rfc.section.1.1">1.1.</a> <a href="#term" id="term">Terminology</a>
</h1>
<p id="rfc.section.1.1.p.1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in BCP 14 <a href="#RFC2119" class="xref">[RFC2119]</a> <a href="#RFC8174" class="xref">[RFC8174]</a> when, and only when, they appear in all capitals, as shown here.  </p>
<p id="rfc.section.1.1.p.2">The terms "public address", "stable address", "temporary address", "constant IID", "stable IID", and "temporary IID" are to be interpreted as specified in <a href="#RFC7721" class="xref">[RFC7721]</a>.</p>
<p id="rfc.section.1.1.p.3">The term "global scope addresses" is used in this document to collectively refer to "Global unicast addresses" as defined in <a href="#RFC4291" class="xref">[RFC4291]</a> and "Unique local addresses" as defined in <a href="#RFC4193" class="xref">[RFC4193]</a>, and not to "globally reachable" as defined in <a href="#RFC8190" class="xref">[RFC8190]</a>.</p>
<h1 id="rfc.section.1.2">
<a href="#rfc.section.1.2">1.2.</a> Problem Statement</h1>
<p id="rfc.section.1.2.p.1">Addresses generated using stateless address autoconfiguration <a href="#RFC4862" class="xref">[RFC4862]</a> contain an embedded interface identifier, which may remain stable over time. Anytime a fixed identifier is used in multiple contexts, it becomes possible to correlate seemingly unrelated activity using this identifier.</p>
<p id="rfc.section.1.2.p.2">The correlation can be performed by </p>

<ul>
<li>An attacker who is in the path between the node in question and the peer(s) to which it is communicating, and who can view the IPv6 addresses present in the datagrams.</li>
<li>An attacker who can access the communication logs of the peers with which the node has communicated.</li>
</ul>
<p id="rfc.section.1.2.p.3">Since the identifier is embedded within the IPv6 address, it cannot be hidden. This document proposes a solution to this issue by generating interface identifiers that vary over time.</p>
<p id="rfc.section.1.2.p.4">Note that an attacker, who is on path, may be able to perform significant correlation on unencrypted packets based on <a href="#RFC7624" class="xref">[RFC7624]</a>. Nor will it prevent an on-link observer (e.g. the node's default router) to track all the node's addresses.</p>

<ul>
<li>The payload contents of the packets on the wire</li>
<li>The characteristics of the packets such as packet size and timing</li>
</ul>

<p>Use of temporary addresses will not prevent such payload-based correlation, which can only be addressed by widespread deployment of encryption as advocated in </p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#SECTION2" id="SECTION2">Background</a>
</h1>
<p id="rfc.section.2.p.1">This section discusses the problem in more detail, and provides context for evaluating the significance of the concerns in specific environments and makes comparisons with existing practices.</p>
<h1 id="rfc.section.2.1">
<a href="#rfc.section.2.1">2.1.</a> Extended Use of the Same Identifier</h1>
<p id="rfc.section.2.1.p.1">The use of a non-changing interface identifier to form addresses is a specific instance of the more general case where a constant identifier is reused over an extended period of time and in multiple independent activities.  Any time the same identifier is used in multiple contexts, it becomes possible for that identifier to be used to correlate seemingly unrelated activity. For example, a network sniffer placed strategically on a link across which all traffic to/from a particular host crosses could keep track of which destinations a node communicated with and at what times. Such information can in some cases be used to infer things, such as what hours an employee was active, when someone is at home, etc. Although it might appear that changing an address regularly in such environments would be desirable to lessen privacy concerns, it should be noted that the network prefix portion of an address also serves as a constant identifier. All nodes at, say, a home, would have the same network prefix, which identifies the topological location of those nodes. This has implications for privacy, though not at the same granularity as the concern that this document addresses. Specifically, all nodes within a home could be grouped together for the purposes of collecting information. If the network contains a very small number of nodes, say, just one, changing just the interface identifier will not enhance privacy, since the prefix serves as a constant identifier.</p>
<p id="rfc.section.2.1.p.2">One of the requirements for correlating seemingly unrelated activities is the use (and reuse) of an identifier that is recognizable over time within different contexts. IP addresses provide one obvious example, but there are more. Many nodes also have DNS names associated with their addresses, in which case the DNS name serves as a similar identifier. Although the DNS name associated with an address is more work to obtain (it may require a DNS query), the information is often readily available. In such cases, changing the address on a machine over time would do little to address the concerns raised in this document, unless the DNS name is changed as well (see <a href="#SECTION4" class="xref">Section 4</a>).</p>
<p id="rfc.section.2.1.p.3">Web browsers and servers typically exchange "cookies" with each other <a href="#RFC6265" class="xref">[RFC6265]</a>. Cookies allow web servers to correlate a current activity with a previous activity. One common usage is to send back targeted advertising to a user by using the cookie supplied by the browser to identify what earlier queries had been made (e.g., for what type of information). Based on the earlier queries, advertisements can be targeted to match the (assumed) interests of the end-user.</p>
<p id="rfc.section.2.1.p.4">The use of a constant identifier within an address is of special concern because addresses are a fundamental requirement of communication and cannot easily be hidden from eavesdroppers and other parties. Even when higher layers encrypt their payloads, addresses in packet headers appear in the clear. Consequently, if a mobile host (e.g., laptop) accessed the network from several different locations, an eavesdropper might be able to track the movement of that mobile host from place to place, even if the upper layer payloads were encrypted.</p>
<p id="rfc.section.2.1.p.5">Using temporary addresses alone is not sufficient to prevent all forms of tracking. It is however clear that temporary addresses are useful to improve user privacy.</p>
<p id="rfc.section.2.1.p.6">The security and privacy implications of IPv6 addresses are discussed in detail in <a href="#RFC7721" class="xref">[RFC7721]</a>, <a href="#RFC7707" class="xref">[RFC7707]</a>, and <a href="#RFC7217" class="xref">[RFC7217]</a>.  </p>
<h1 id="rfc.section.2.2">
<a href="#rfc.section.2.2">2.2.</a> Possible Approaches</h1>
<p id="rfc.section.2.2.p.1">One way to avoid having a stable non-changing address is to use DHCPv6 <a href="#RFC8415" class="xref">[RFC8415]</a> for obtaining addresses.  Section 12 of <a href="#RFC8415" class="xref">[RFC8415]</a> discusses the use of DHCPv6 for the assignment and management of "temporary addresses", which are never renewed and provide the same property of temporary addresses described in this document with regards to the privacy concern.</p>
<p id="rfc.section.2.2.p.2">Another approach, compatible with the stateless address autoconfiguration architecture, would be to change the interface identifier portion of an address over time. Changing the interface identifier can make it more difficult to look at the IP addresses in independent transactions and identify which ones actually correspond to the same node, both in the case where the routing prefix portion of an address changes and when it does not.</p>
<p id="rfc.section.2.2.p.3">Many machines function as both clients and servers. In such cases, the machine would need a DNS name for its use as a server. Whether the address stays fixed or changes has little privacy implication since the DNS name remains constant and serves as a constant identifier. When acting as a client (e.g., initiating communication), however, such a machine may want to vary the addresses it uses. In such environments, one may need multiple addresses: a stable address registered in the DNS, that is used to accept incoming connection requests from other machines, and a temporary address used to shield the identity of the client when it initiates communication.  </p>
<p id="rfc.section.2.2.p.4">On the other hand, a machine that functions only as a client may want to employ only temporary addresses for public communication.</p>
<p id="rfc.section.2.2.p.5">To make it difficult to make educated guesses as to whether two different interface identifiers belong to the same node, the algorithm for generating alternate identifiers must include input that has an unpredictable component from the perspective of the outside entities that are collecting information.</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#SECTION3" id="SECTION3">Protocol Description</a>
</h1>
<p id="rfc.section.3.p.1">This section defines the procedures for the generation of IPv6 temporary addresses with the following properties:</p>
<p></p>

<ol>
<li>Temporary addresses are typically employed for initiating outgoing sessions.</li>
<li>Temporary addresses are used for a short period of time (typically hours to days) and are subsequently deprecated. Deprecated addresses can continue to be used for established connections, but are not used to initiate new connections. </li>
<li>New temporary addresses are generated periodically to replace temporary addresses that expire.</li>
<li>Temporary addresses must have a limited lifetime (limited "valid lifetime" and "preferred lifetime" from <a href="#RFC4862" class="xref">[RFC4862]</a>), that should be statistically different for different addresses. The lifetime of an address should be further reduced when privacy-meaningful events (such as a node attaching to a different network, or the regeneration of a new randomized MAC address) takes place.</li>
<li>By default, one address is generated for each prefix advertised by stateless address autoconfiguration. The resulting Interface Identifiers must be statistically different when addresses are configured for different prefixes.  That is, when temporary addresses are generated for different autoconfiguration prefixes for the same network interface, the resulting Interface Identifiers must be statistically different.  This means that, given two addresses that employ different prefixes, it must be difficult for an outside entity to tell whether the addresses correspond to the same network interface or even whether they have been generated by the same host.  </li>
<li>It must be difficult for an outside entity to predict the Interface Identifiers that will be employed for temporary addresses, even with knowledge of the algorithm/method employed to generate them and/or knowledge of the Interface Identifiers previously employed for other temporary addresses. These Interface Identifiers must be semantically opaque <a href="#RFC7136" class="xref">[RFC7136]</a> and must not follow any specific patterns.</li>
</ol>

<p> </p>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> Assumptions</h1>
<p id="rfc.section.3.1.p.1">The following algorithm assumes that for a given temporary address, an implementation can determine the prefix from which it was generated. When a temporary address is deprecated, a new temporary address is generated. The specific valid and preferred lifetimes for the new address are dependent on the corresponding lifetime values set for the prefix from which it was generated.</p>
<p id="rfc.section.3.1.p.2">Finally, this document assumes that when a node initiates outgoing communication, temporary addresses can be given preference over stable addresses (if available), when the device is configured to do so.  <a href="#RFC6724" class="xref">[RFC6724]</a> mandates implementations to provide a mechanism, which allows an application to configure its preference for temporary addresses over stable addresses. It also allows for an implementation to prefer temporary addresses by default, so that the connections initiated by the node can use temporary addresses without requiring application-specific enablement. This document also assumes that an API will exist that allows individual applications to indicate whether they prefer to use temporary or stable addresses and override the system defaults.  </p>
<h1 id="rfc.section.3.2">
<a href="#rfc.section.3.2">3.2.</a> <a href="#SECTION3_2" id="SECTION3_2">Generation of Randomized Interface Identifiers</a>
</h1>
<p id="rfc.section.3.2.p.1">The following subsections specify example algorithms for generating temporary interface identifiers that follow the guidelines in <a href="#SECTION3" class="xref">Section 3</a> of this document. The algorithm specified in <a href="#randomized-IIDs" class="xref">Section 3.2.1</a> benefits from a Pseudo-Random Number Generator (PRNG) available on the system. The algorithm specified in <a href="#RFC-7217" class="xref">Section 3.2.2</a> allows for code reuse by nodes that implement <a href="#RFC7217" class="xref">[RFC7217]</a>.  </p>
<h1 id="rfc.section.3.2.1">
<a href="#rfc.section.3.2.1">3.2.1.</a> <a href="#randomized-IIDs" id="randomized-IIDs">Simple Randomized Interface Identifiers</a>
</h1>
<p id="rfc.section.3.2.1.p.1">One approach is to select a pseudorandom number of the appropriate length. A node employing this algorithm should generate IIDs as follows: </p>

<ol>
<li>Obtain a random number (see <a href="#RFC4086" class="xref">[RFC4086]</a> for randomness requirements for security).</li>
<li>The Interface Identifier is obtained by taking as many bits from the random number obtained in the previous step as necessary. Note: there are no special bits in an Interface Identifier <a href="#RFC7136" class="xref">[RFC7136]</a>.  <dl>
<dt></dt>
<dd style="margin-left: 8">We note that <a href="#RFC4291" class="xref">[RFC4291]</a> requires that the Interface IDs of all unicast addresses (except those that start with the binary value 000) be 64 bits long. However, the method discussed in this document could be employed for generating Interface IDs of any arbitrary length, albeit at the expense of reduced entropy (when employing Interface IDs smaller than 64 bits).</dd>
</dl>
<p> </p>
</li>
<li>The resulting Interface Identifier SHOULD be compared against the reserved IPv6 Interface Identifiers <a href="#RFC5453" class="xref">[RFC5453]</a> <a href="#IANA-RESERVED-IID" class="xref">[IANA-RESERVED-IID]</a> and against those Interface Identifiers already employed in an address of the same network interface and the same network prefix. In the event that an unacceptable identifier has been generated, a new interface identifier should be generated, by repeating the algorithm from the first step.  </li>
</ol>

<p> </p>
<h1 id="rfc.section.3.2.2">
<a href="#rfc.section.3.2.2">3.2.2.</a> <a href="#RFC-7217" id="RFC-7217">Hash-based Generation of Randomized Interface Identifiers</a>
</h1>
<p id="rfc.section.3.2.2.p.1">The algorithm in <a href="#RFC7217" class="xref">[RFC7217]</a> can be augmented for the generation of temporary addresses. The benefit of this would be that a node could employ a single algorithm for generating stable and temporary addresses, by employing appropriate parameters.</p>
<p id="rfc.section.3.2.2.p.2">Nodes would employ the following algorithm for generating the temporary IID: </p>

<ol>
<li>Compute a random identifier with the expression: <br><br> RID = F(Prefix, MAC_Address, Network_ID, Time, DAD_Counter, secret_key) <br><br> Where: <dl>
<dt>RID:</dt>
<dd style="margin-left: 8">
<br>Random Identifier</dd>
<dt>F():</dt>
<dd style="margin-left: 8">
<br>A pseudorandom function (PRF) that MUST NOT be computable from the outside (without knowledge of the secret key). F() MUST also be difficult to reverse, such that it resists attempts to obtain the secret_key, even when given samples of the output of F() and knowledge or control of the other input parameters. F() SHOULD produce an output of at least 64 bits. F() could be implemented as a cryptographic hash of the concatenation of each of the function parameters. SHA-256 is one possible option for F(). Note: MD5 <a href="#RFC1321" class="xref">[RFC1321]</a> is considered unacceptable for F() <a href="#RFC6151" class="xref">[RFC6151]</a>.</dd>
<dt>Prefix:</dt>
<dd style="margin-left: 8">
<br>The prefix to be used for SLAAC, as learned from an ICMPv6 Router Advertisement message.</dd>
<dt>MAC_Address:</dt>
<dd style="margin-left: 8">
<br>The MAC address corresponding to the underlying network interface card, in the case the link uses IEEE802 link-layer identifiers. Employing the MAC address in this expression (in replacement of the Net_Iface parameter of the expression in RFC7217) means that the re-generation of a randomized MAC address will result in a different temporary address.</dd>
<dt>Network_ID:</dt>
<dd style="margin-left: 8">
<br>Some network-specific data that identifies the subnet to which this interface is attached -- for example, the IEEE 802.11 Service Set Identifier (SSID) corresponding to the network to which this interface is associated. Additionally, Simple DNA <a href="#RFC6059" class="xref">[RFC6059]</a> describes ideas that could be leveraged to generate a Network_ID parameter. This parameter is SHOULD be employed if some form of "Network_ID" is available.</dd>
<dt>Time:</dt>
<dd style="margin-left: 8">
<br>An implementation-dependent representation of time. One possible example is the representation in UNIX-like systems <a href="#OPEN-GROUP" class="xref">[OPEN-GROUP]</a>, that measure time in terms of the number of seconds elapsed since the Epoch (00:00:00 Coordinated Universal Time (UTC), 1 January 1970).</dd>
<dt>DAD_Counter:</dt>
<dd style="margin-left: 8">
<br>A counter that is employed to resolve Duplicate Address Detection (DAD) conflicts.</dd>
<dt>secret_key:</dt>
<dd style="margin-left: 8">
<br>A secret key that is not known by the attacker. The secret key SHOULD be of at least 128 bits. It MUST be initialized to a pseudo-random number (see <a href="#RFC4086" class="xref">[RFC4086]</a> for randomness requirements for security) when the operating system is "bootstrapped".  </dd>
</dl>
<p> </p>
</li>
<li>The Interface Identifier is finally obtained by taking as many bits from the RID value (computed in the previous step) as necessary, starting from the least significant bit.  The resulting Interface Identifier SHOULD be compared against the reserved IPv6 Interface Identifiers <a href="#RFC5453" class="xref">[RFC5453]</a> <a href="#IANA-RESERVED-IID" class="xref">[IANA-RESERVED-IID]</a> and against those Interface Identifiers already employed in an address of the same network interface and the same network prefix. In the event that an unacceptable identifier has been generated, the value DAD_Counter should be incremented by 1, and the algorithm should be restarted from the first step.  </li>
</ol>

<p> </p>
<h1 id="rfc.section.3.3">
<a href="#rfc.section.3.3">3.3.</a> <a href="#SECTION3_3" id="SECTION3_3">Generating Temporary Addresses</a>
</h1>
<p><a href="#RFC4862" class="xref">[RFC4862]</a> describes the steps for generating a link-local address when an interface becomes enabled as well as the steps for generating addresses for other scopes. This document extends <a href="#RFC4862" class="xref">[RFC4862]</a> as follows. When processing a Router Advertisement with a Prefix Information option carrying a prefix for the purposes of address autoconfiguration (i.e., the A bit is set), the node MUST perform the following steps:</p>
<p></p>

<ol>
<li>Process the Prefix Information Option as defined in <a href="#RFC4862" class="xref">[RFC4862]</a>, adjusting the lifetimes of existing temporary addresses. If a received option may extend the lifetimes of temporary addresses, with the overall constraint that no temporary addresses should ever remain "valid" or "preferred" for a time longer than (TEMP_VALID_LIFETIME) or (TEMP_PREFERRED_LIFETIME - DESYNC_FACTOR) respectively. The configuration variables TEMP_VALID_LIFETIME and TEMP_PREFERRED_LIFETIME correspond to approximate target lifetimes for temporary addresses.</li>
<li>One way an implementation can satisfy the above constraints is to associate with each temporary address a creation time (called CREATION_TIME) that indicates the time at which the address was created. When updating the preferred lifetime of an existing temporary address, it would be set to expire at whichever time is earlier: the time indicated by the received lifetime or (CREATION_TIME + TEMP_PREFERRED_LIFETIME - DESYNC_FACTOR). A similar approach can be used with the valid lifetime.</li>
<li>If the node has not configured any temporary address for the corresponding prefix, the node SHOULD create a new temporary address for such prefix.  <dl>
<dt>Note:</dt>
<dd style="margin-left: 8">
<br>For example, a host might implement prefix-specific policies such as not configuring temporary addresses for the Unique Local IPv6 Unicast Addresses (ULA) <a href="#RFC4193" class="xref">[RFC4193]</a> prefix.</dd>
</dl>
<p> </p>
</li>
<li>When creating a temporary address, the lifetime values MUST be derived from the corresponding prefix as follows: <ul>
<li>Its Valid Lifetime is the lower of the Valid Lifetime of the prefix and TEMP_VALID_LIFETIME</li>
<li>Its Preferred Lifetime is the lower of the Preferred Lifetime of the prefix and TEMP_PREFERRED_LIFETIME - DESYNC_FACTOR.</li>
</ul>
</li>
<li>A temporary address is created only if this calculated Preferred Lifetime is greater than REGEN_ADVANCE time units. In particular, an implementation MUST NOT create a temporary address with a zero Preferred Lifetime.</li>
<li>New temporary addresses MUST be created by appending a randomized interface identifier (generates as described in <a href="#SECTION3_2" class="xref">Section 3.2</a> of this document) to the prefix that was received.</li>
<li>The node MUST perform duplicate address detection (DAD) on the generated temporary address. If DAD indicates the address is already in use, the node MUST generate a new randomized interface identifier, and repeat the previous steps as appropriate up to TEMP_IDGEN_RETRIES times. If after TEMP_IDGEN_RETRIES consecutive attempts no non-unique address was generated, the node MUST log a system error and MUST NOT attempt to generate temporary addresses for that interface.</li>
</ol>

<p> </p>
<h1 id="rfc.section.3.4">
<a href="#rfc.section.3.4">3.4.</a> <a href="#SECTION3_4" id="SECTION3_4">Expiration of Temporary Addresses</a>
</h1>
<p id="rfc.section.3.4.p.1">When a temporary address becomes deprecated, a new one MUST be generated. This is done by repeating the actions described in <a href="#SECTION3_3" class="xref">Section 3.3</a>, starting at step 4). Note that, except for the transient period when a temporary address is being regenerated, in normal operation at most one temporary address per prefix should be in a non-deprecated state at any given time on a given interface. Note that if a temporary address becomes deprecated as result of processing a Prefix Information Option with a zero Preferred Lifetime, then a new temporary address MUST NOT be generated. To ensure that a preferred temporary address is always available, a new temporary address SHOULD be regenerated slightly before its predecessor is deprecated. This is to allow sufficient time to avoid race conditions in the case where generating a new temporary address is not instantaneous, such as when duplicate address detection must be run. The node SHOULD start the address regeneration process REGEN_ADVANCE time units before a temporary address would actually be deprecated.</p>
<p id="rfc.section.3.4.p.2">As an optional optimization, an implementation MAY remove a deprecated temporary address that is not in use by applications or upper layers as detailed in <a href="#SECTION6" class="xref">Section 6</a>.</p>
<h1 id="rfc.section.3.5">
<a href="#rfc.section.3.5">3.5.</a> <a href="#REGEN" id="REGEN">Regeneration of Temporary Addresses</a>
</h1>
<p id="rfc.section.3.5.p.1">The frequency at which temporary addresses change depends on how a device is being used (e.g., how frequently it initiates new communication) and the concerns of the end user. The most egregious privacy concerns appear to involve addresses used for long periods of time (weeks to months to years). The more frequently an address changes, the less feasible collecting or coordinating information keyed on interface identifiers becomes. Moreover, the cost of collecting information and attempting to correlate it based on interface identifiers will only be justified if enough addresses contain non-changing identifiers to make it worthwhile. Thus, having large numbers of clients change their address on a daily or weekly basis is likely to be sufficient to alleviate most privacy concerns.</p>
<p id="rfc.section.3.5.p.2">There are also client costs associated with having a large number of addresses associated with a node (e.g., in doing address lookups, the need to join many multicast groups, etc.). Thus, changing addresses frequently (e.g., every few minutes) may have performance implications.</p>
<p id="rfc.section.3.5.p.3">Nodes following this specification SHOULD generate new temporary addresses on a periodic basis. This can be achieved by generating a new temporary address at least once every (TEMP_PREFERRED_LIFETIME - REGEN_ADVANCE - DESYNC_FACTOR) time units. As described above, generating a new temporary address REGEN_ADVANCE time units before a temporary address becomes deprecated produces addresses with a preferred lifetime no larger than TEMP_PREFERRED_LIFETIME. The value DESYNC_FACTOR is a random value (different for each client) that ensures that clients don't synchronize with each other and generate new addresses at exactly the same time. When the preferred lifetime expires, a new temporary address MUST be generated using the new randomized interface identifier.</p>
<p id="rfc.section.3.5.p.4">Because the precise frequency at which it is appropriate to generate new addresses varies from one environment to another, implementations SHOULD provide end users with the ability to change the frequency at which addresses are regenerated. The default value is given in TEMP_PREFERRED_LIFETIME and is one day. In addition, the exact time at which to invalidate a temporary address depends on how applications are used by end users. Thus, the suggested default value of one week (TEMP_VALID_LIFETIME) may not be appropriate in all environments. Implementations SHOULD provide end users with the ability to override both of these default values.</p>
<p id="rfc.section.3.5.p.5">Finally, when an interface connects to a new (different) link, a new set of temporary addresses MUST be generated immediately for use on the new link.  If a device moves from one link to another, generating a new set of temporary addresses ensures that the device uses different randomized interface identifiers for the temporary addresses associated with the two links, making it more difficult to correlate addresses from the two different links as being from the same node. The node MAY follow any process available to it, to determine that the link change has occurred. One such process is described by "Simple Procedures for Detecting Network Attachment in IPv6" <a href="#RFC6059" class="xref">[RFC6059]</a>. Detecting link changes would prevent link down/up events from causing temporary addresses to be (unnecessarily) regenerated.</p>
<h1 id="rfc.section.3.6">
<a href="#rfc.section.3.6">3.6.</a> Implementation Considerations</h1>
<p id="rfc.section.3.6.p.1">Devices implementing this specification MUST provide a way for the end user to explicitly enable or disable the use of temporary addresses. In addition, a site might wish to disable the use of temporary addresses in order to simplify network debugging and operations. Consequently, implementations SHOULD provide a way for trusted system administrators to enable or disable the use of temporary addresses.</p>
<p id="rfc.section.3.6.p.2">Additionally, sites might wish to selectively enable or disable the use of temporary addresses for some prefixes.  For example, a site might wish to disable temporary address generation for "Unique local" <a href="#RFC4193" class="xref">[RFC4193]</a> prefixes while still generating temporary addresses for all other global prefixes. Another site might wish to enable temporary address generation only for the prefixes 2001::/16 and 2002::/16 while disabling it for all other prefixes. To support this behavior, implementations SHOULD provide a way to enable and disable generation of temporary addresses for specific prefix subranges. This per-prefix setting SHOULD override the global settings on the node with respect to the specified prefix subranges. Note that the per-prefix setting can be applied at any granularity, and not necessarily on a per subnet basis.</p>
<p id="rfc.section.3.6.p.3">The use of temporary addresses may cause unexpected difficulties with some applications. As described below, some servers refuse to accept communications from clients for which they cannot map the IP address into a DNS name.  In addition, some applications may not behave robustly if temporary addresses are used and an address expires before the application has terminated, or if it opens multiple sessions, but expects them to all use the same addresses.  </p>
<p id="rfc.section.3.6.p.4">If a very small number of nodes (say, only one) use a given prefix for extended periods of time, just changing the interface identifier part of the address may not be sufficient to ensure privacy, since the prefix acts as a constant identifier. The procedures described in this document are most effective when the prefix is reasonably non static or is used by a fairly large number of nodes.</p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#SECTION4" id="SECTION4">Implications of Changing Interface Identifiers</a>
</h1>
<p id="rfc.section.4.p.1">The desires of protecting individual privacy versus the desire to effectively maintain and debug a network can conflict with each other. Having clients use addresses that change over time will make it more difficult to track down and isolate operational problems. For example, when looking at packet traces, it could become more difficult to determine whether one is seeing behavior caused by a single errant machine, or by a number of them.</p>
<p id="rfc.section.4.p.2">Some servers refuse to grant access to clients for which no DNS name exists. That is, they perform a DNS PTR query to determine the DNS name, and may then also perform an AAAA query on the returned name to verify that the returned DNS name maps back into the address being used. Consequently, clients not properly registered in the DNS may be unable to access some services. As noted earlier, however, a node's DNS name (if non-changing) serves as a constant identifier. The wide deployment of the extension described in this document could challenge the practice of inverse-DNS-based "authentication," which has little validity, though it is widely implemented. In order to meet server challenges, nodes could register temporary addresses in the DNS using random names (for example, a string version of the random address itself).</p>
<p id="rfc.section.4.p.3">Use of the extensions defined in this document may complicate debugging and other operational troubleshooting activities. Consequently, it may be site policy that temporary addresses should not be used. Consequently, implementations MUST provide a method for the end user or trusted administrator to override the use of temporary addresses.</p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> Defined Constants</h1>
<p id="rfc.section.5.p.1">Constants defined in this document include:</p>
<p id="rfc.section.5.p.2">TEMP_VALID_LIFETIME -- Default value: 1 week. Users should be able to override the default value.</p>
<p id="rfc.section.5.p.3">TEMP_PREFERRED_LIFETIME -- Default value: 1 day. Users should be able to override the default value.</p>
<p id="rfc.section.5.p.4">REGEN_ADVANCE -- 5 seconds</p>
<p id="rfc.section.5.p.5">MAX_DESYNC_FACTOR -- 10 minutes. Upper bound on DESYNC_FACTOR.</p>
<p id="rfc.section.5.p.6">DESYNC_FACTOR -- A random value within the range 0 - MAX_DESYNC_FACTOR. It is computed once at system start (rather than each time it is used) and must never be greater than (TEMP_PREFERRED_LIFETIME - REGEN_ADVANCE).</p>
<p id="rfc.section.5.p.7">TEMP_IDGEN_RETRIES -- Default value: 3</p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#SECTION6" id="SECTION6">Future Work</a>
</h1>
<p id="rfc.section.6.p.1">An implementation might want to keep track of which addresses are being used by upper layers so as to be able to remove a deprecated temporary address from internal data structures once no upper layer protocols are using it (but not before). This is in contrast to current approaches where addresses are removed from an interface when they become invalid <a href="#RFC4862" class="xref">[RFC4862]</a>, independent of whether or not upper layer protocols are still using them. For TCP connections, such information is available in control blocks.  For UDP-based applications, it may be the case that only the applications have knowledge about what addresses are actually in use. Consequently, an implementation generally will need to use heuristics in deciding when an address is no longer in use.</p>
<p id="rfc.section.6.p.2">Recommendations on DNS practices to avoid the problem described in <a href="#SECTION4" class="xref">Section 4</a> when reverse DNS lookups fail may be needed.  <a href="#RFC4472" class="xref">[RFC4472]</a> contains a more detailed discussion of the DNS-related issues.</p>
<p id="rfc.section.6.p.3">While this document discusses ways of obscuring a user's IP address, the method described is believed to be ineffective against sophisticated forms of traffic analysis.  To increase effectiveness, one may need to consider the use of more advanced techniques, such as Onion Routing <a href="#ONION" class="xref">[ONION]</a>.</p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> Security Considerations</h1>
<p id="rfc.section.7.p.1">Ingress filtering has been and is being deployed as a means of preventing the use of spoofed source addresses in Distributed Denial of Service (DDoS) attacks. In a network with a large number of nodes, new temporary addresses are created at a fairly high rate. This might make it difficult for ingress filtering mechanisms to distinguish between legitimately changing temporary addresses and spoofed source addresses, which are "in-prefix" (using a topologically correct prefix and non-existent interface ID). This can be addressed by using access control mechanisms on a per-address basis on the network egress point.</p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> Significant Changes from RFC4941</h1>
<p id="rfc.section.8.p.1">This section summarizes the changes in this document relative to RFC 4941 that an implementer of RFC 4941 should be aware of.  </p>

<ol>
<li>Discussion of IEEE-based IIDs has been removed, since the current recommendation (<a href="#RFC8064" class="xref">[RFC8064]</a>) is to employ <a href="#RFC7217" class="xref">[RFC7217]</a>).</li>
<li>The document employs the terminology from <a href="#RFC7721" class="xref">[RFC7721]</a>.</li>
<li>Sections 2.2 and 2.3 of <a href="#RFC4941" class="xref">[RFC4941]</a> have been removed since the topic has been discussed in more detail in e.g. <a href="#RFC7721" class="xref">[RFC7721]</a>.</li>
<li>The algorithm specified in Section 3.2.1 and 3.2.2 of <a href="#RFC4941" class="xref">[RFC4941]</a> was replaced by two possible alternative algorithms.</li>
<li>Generation of stable addresses is not implied or required by this document.</li>
<li>Temporary addresses are *not* disabled by default.</li>
<li>Section 3.2.3 from <a href="#RFC4941" class="xref">[RFC4941]</a> was removed, based on the explanation of that very section of RFC4941.</li>
<li>All the verified errata for <a href="#RFC4941" class="xref">[RFC4941]</a> has been incorporated.</li>
</ol>
<h1 id="rfc.section.9">
<a href="#rfc.section.9">9.</a> Acknowledgments</h1>
<p id="rfc.section.9.p.1">The authors would like to thank (in alphabetical order) Brian Carpenter, Tim Chown, Lorenzo Colitti, David Farmer, Tom Herbert, Bob Hinden, Christian Huitema, Erik Kline, Dave Plonka, Michael Richardson, Mark Smith, Ole Troan, Johanna Ullrich, and Timothy Winters, for providing valuable comments on earlier versions of this document.</p>
<p id="rfc.section.9.p.2">This document incorporates errata submitted for <a href="#RFC4941" class="xref">[RFC4941]</a> by Jiri Bohac and Alfred Hoenes.</p>
<p id="rfc.section.9.p.3">This document is based on <a href="#RFC4941" class="xref">[RFC4941]</a> (a revision of RFC3041). Suresh Krishnan was the sole author of RFC4941. He would like to acknowledge the contributions of the IPv6 working group and, in particular, Jari Arkko, Pekka Nikander, Pekka Savola, Francis Dupont, Brian Haberman, Tatuya Jinmei, and Margaret Wasserman for their detailed comments.</p>
<p id="rfc.section.9.p.4">Rich Draves and Thomas Narten were the authors of RFC 3041.  They would like to acknowledge the contributions of the IPv6 working group and, in particular, Ran Atkinson, Matt Crawford, Steve Deering, Allison Mankin, and Peter Bieringer.  </p>
<h1 id="rfc.references">
<a href="#rfc.references">10.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">10.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a>Bradner, S.</a>, "<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4086">[RFC4086]</b></td>
<td class="top">
<a>Eastlake 3rd, D.</a>, <a>Schiller, J.</a> and <a>S. Crocker</a>, "<a href="https://tools.ietf.org/html/rfc4086">Randomness Requirements for Security</a>", BCP 106, RFC 4086, DOI 10.17487/RFC4086, June 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4193">[RFC4193]</b></td>
<td class="top">
<a>Hinden, R.</a> and <a>B. Haberman</a>, "<a href="https://tools.ietf.org/html/rfc4193">Unique Local IPv6 Unicast Addresses</a>", RFC 4193, DOI 10.17487/RFC4193, October 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4291">[RFC4291]</b></td>
<td class="top">
<a>Hinden, R.</a> and <a>S. Deering</a>, "<a href="https://tools.ietf.org/html/rfc4291">IP Version 6 Addressing Architecture</a>", RFC 4291, DOI 10.17487/RFC4291, February 2006.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4862">[RFC4862]</b></td>
<td class="top">
<a>Thomson, S.</a>, <a>Narten, T.</a> and <a>T. Jinmei</a>, "<a href="https://tools.ietf.org/html/rfc4862">IPv6 Stateless Address Autoconfiguration</a>", RFC 4862, DOI 10.17487/RFC4862, September 2007.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4941">[RFC4941]</b></td>
<td class="top">
<a>Narten, T.</a>, <a>Draves, R.</a> and <a>S. Krishnan</a>, "<a href="https://tools.ietf.org/html/rfc4941">Privacy Extensions for Stateless Address Autoconfiguration in IPv6</a>", RFC 4941, DOI 10.17487/RFC4941, September 2007.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5453">[RFC5453]</b></td>
<td class="top">
<a>Krishnan, S.</a>, "<a href="https://tools.ietf.org/html/rfc5453">Reserved IPv6 Interface Identifiers</a>", RFC 5453, DOI 10.17487/RFC5453, February 2009.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6724">[RFC6724]</b></td>
<td class="top">
<a>Thaler, D.</a>, <a>Draves, R.</a>, <a>Matsumoto, A.</a> and <a>T. Chown</a>, "<a href="https://tools.ietf.org/html/rfc6724">Default Address Selection for Internet Protocol Version 6 (IPv6)</a>", RFC 6724, DOI 10.17487/RFC6724, September 2012.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7136">[RFC7136]</b></td>
<td class="top">
<a>Carpenter, B.</a> and <a>S. Jiang</a>, "<a href="https://tools.ietf.org/html/rfc7136">Significance of IPv6 Interface Identifiers</a>", RFC 7136, DOI 10.17487/RFC7136, February 2014.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7217">[RFC7217]</b></td>
<td class="top">
<a>Gont, F.</a>, "<a href="https://tools.ietf.org/html/rfc7217">A Method for Generating Semantically Opaque Interface Identifiers with IPv6 Stateless Address Autoconfiguration (SLAAC)</a>", RFC 7217, DOI 10.17487/RFC7217, April 2014.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8064">[RFC8064]</b></td>
<td class="top">
<a>Gont, F.</a>, <a>Cooper, A.</a>, <a>Thaler, D.</a> and <a>W. Liu</a>, "<a href="https://tools.ietf.org/html/rfc8064">Recommendation on Stable IPv6 Interface Identifiers</a>", RFC 8064, DOI 10.17487/RFC8064, February 2017.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8174">[RFC8174]</b></td>
<td class="top">
<a>Leiba, B.</a>, "<a href="https://tools.ietf.org/html/rfc8174">Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</a>", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8190">[RFC8190]</b></td>
<td class="top">
<a>Bonica, R.</a>, <a>Cotton, M.</a>, <a>Haberman, B.</a> and <a>L. Vegoda</a>, "<a href="https://tools.ietf.org/html/rfc8190">Updates to the Special-Purpose IP Address Registries</a>", BCP 153, RFC 8190, DOI 10.17487/RFC8190, June 2017.</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">10.2.</a> Informative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="FIPS-SHS">[FIPS-SHS]</b></td>
<td class="top">
<a>NIST</a>, "<a href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf">Secure Hash Standard (SHS)</a>", FIPS Publication 180-4, August 2015.</td>
</tr>
<tr>
<td class="reference"><b id="IANA-RESERVED-IID">[IANA-RESERVED-IID]</b></td>
<td class="top">
<a>IANA</a>, "<a href="http://www.iana.org/assignments/ipv6-interface-ids">Reserved IPv6 Interface Identifiers</a>"</td>
</tr>
<tr>
<td class="reference"><b id="ONION">[ONION]</b></td>
<td class="top">
<a>Reed, MGR.</a>, <a>Syverson, PFS.</a> and <a>DMG. Goldschlag</a>, "<a>Proxies for Anonymous Routing</a>",  Proceedings of the 12th Annual Computer Security Applications Conference, San Diego, CA, December 1996.</td>
</tr>
<tr>
<td class="reference"><b id="OPEN-GROUP">[OPEN-GROUP]</b></td>
<td class="top">
<a>The Open Group</a>, "<a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/contents.html">The Open Group Base Specifications Issue 7 / IEEE Std 1003.1-2008, 2016 Edition</a>", Section 4.16 Seconds Since the Epoch, 2016.</td>
</tr>
<tr>
<td class="reference"><b id="RFC1321">[RFC1321]</b></td>
<td class="top">
<a>Rivest, R.</a>, "<a href="https://tools.ietf.org/html/rfc1321">The MD5 Message-Digest Algorithm</a>", RFC 1321, DOI 10.17487/RFC1321, April 1992.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4472">[RFC4472]</b></td>
<td class="top">
<a>Durand, A.</a>, <a>Ihren, J.</a> and <a>P. Savola</a>, "<a href="https://tools.ietf.org/html/rfc4472">Operational Considerations and Issues with IPv6 DNS</a>", RFC 4472, DOI 10.17487/RFC4472, April 2006.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5014">[RFC5014]</b></td>
<td class="top">
<a>Nordmark, E.</a>, <a>Chakrabarti, S.</a> and <a>J. Laganier</a>, "<a href="https://tools.ietf.org/html/rfc5014">IPv6 Socket API for Source Address Selection</a>", RFC 5014, DOI 10.17487/RFC5014, September 2007.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6059">[RFC6059]</b></td>
<td class="top">
<a>Krishnan, S.</a> and <a>G. Daley</a>, "<a href="https://tools.ietf.org/html/rfc6059">Simple Procedures for Detecting Network Attachment in IPv6</a>", RFC 6059, DOI 10.17487/RFC6059, November 2010.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6151">[RFC6151]</b></td>
<td class="top">
<a>Turner, S.</a> and <a>L. Chen</a>, "<a href="https://tools.ietf.org/html/rfc6151">Updated Security Considerations for the MD5 Message-Digest and the HMAC-MD5 Algorithms</a>", RFC 6151, DOI 10.17487/RFC6151, March 2011.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6265">[RFC6265]</b></td>
<td class="top">
<a>Barth, A.</a>, "<a href="https://tools.ietf.org/html/rfc6265">HTTP State Management Mechanism</a>", RFC 6265, DOI 10.17487/RFC6265, April 2011.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7624">[RFC7624]</b></td>
<td class="top">
<a>Barnes, R.</a>, <a>Schneier, B.</a>, <a>Jennings, C.</a>, <a>Hardie, T.</a>, <a>Trammell, B.</a>, <a>Huitema, C.</a> and <a>D. Borkmann</a>, "<a href="https://tools.ietf.org/html/rfc7624">Confidentiality in the Face of Pervasive Surveillance: A Threat Model and Problem Statement</a>", RFC 7624, DOI 10.17487/RFC7624, August 2015.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7707">[RFC7707]</b></td>
<td class="top">
<a>Gont, F.</a> and <a>T. Chown</a>, "<a href="https://tools.ietf.org/html/rfc7707">Network Reconnaissance in IPv6 Networks</a>", RFC 7707, DOI 10.17487/RFC7707, March 2016.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7721">[RFC7721]</b></td>
<td class="top">
<a>Cooper, A.</a>, <a>Gont, F.</a> and <a>D. Thaler</a>, "<a href="https://tools.ietf.org/html/rfc7721">Security and Privacy Considerations for IPv6 Address Generation Mechanisms</a>", RFC 7721, DOI 10.17487/RFC7721, March 2016.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8415">[RFC8415]</b></td>
<td class="top">
<a>Mrugalski, T.</a>, <a>Siodelski, M.</a>, <a>Volz, B.</a>, <a>Yourtchenko, A.</a>, <a>Richardson, M.</a>, <a>Jiang, S.</a>, <a>Lemon, T.</a> and <a>T. Winters</a>, "<a href="https://tools.ietf.org/html/rfc8415">Dynamic Host Configuration Protocol for IPv6 (DHCPv6)</a>", RFC 8415, DOI 10.17487/RFC8415, November 2018.</td>
</tr>
</tbody></table>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Fernando Gont</span> 
	  <span class="n hidden">
		<span class="family-name">Gont</span>
	  </span>
	</span>
	<span class="org vcardline">SI6 Networks / UTN-FRH</span>
	<span class="adr">
	  <span class="vcardline">Evaristo Carriego 2644</span>

	  <span class="vcardline">
		<span class="locality">Haedo</span>,  
		<span class="region">Provincia de Buenos Aires</span> 
		<span class="code">1706</span>
	  </span>
	  <span class="country-name vcardline">Argentina</span>
	</span>
	<span class="vcardline">Phone: +54 11 4650 8472</span>

<span class="vcardline">EMail: <a href="mailto:fgont@si6networks.com">fgont@si6networks.com</a></span>

<span class="vcardline">URI: <a href="http://www.si6networks.com">http://www.si6networks.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Suresh Krishnan</span> 
	  <span class="n hidden">
		<span class="family-name">Krishnan</span>
	  </span>
	</span>
	<span class="org vcardline">Ericsson Research</span>
	<span class="adr">
	  <span class="vcardline">8400 Decarie Blvd.</span>

	  <span class="vcardline">
		<span class="locality">Town of Mount Royal</span>,  
		<span class="region">QC</span> 
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">Canada</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:suresh.krishnan@ericsson.com">suresh.krishnan@ericsson.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Thomas Narten</span> 
	  <span class="n hidden">
		<span class="family-name">Narten</span>
	  </span>
	</span>
	<span class="org vcardline">IBM Corporation</span>
	<span class="adr">
	  <span class="vcardline">P.O. Box 12195</span>

	  <span class="vcardline">
		<span class="locality">Research Triangle Park</span>,  
		<span class="region">NC</span> 
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">USA</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:narten@us.ibm.com">narten@us.ibm.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Richard Draves</span> 
	  <span class="n hidden">
		<span class="family-name">Draves</span>
	  </span>
	</span>
	<span class="org vcardline">Microsoft Research</span>
	<span class="adr">
	  <span class="vcardline">One Microsoft Way</span>

	  <span class="vcardline">
		<span class="locality">Redmond</span>,  
		<span class="region">WA</span> 
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">USA</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:richdr@microsoft.com">richdr@microsoft.com</a></span>

  </address>
</div>

</body>
</html>
